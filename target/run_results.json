{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.2", "generated_at": "2025-02-23T10:06:49.674237Z", "invocation_id": "cd330adc-9fc4-4cab-b152-0b4bf893ba80", "env": {}}, "results": [{"status": "error", "timing": [{"name": "compile", "started_at": "2025-02-23T10:06:49.603810Z", "completed_at": "2025-02-23T10:06:49.634976Z"}, {"name": "execute", "started_at": "2025-02-23T10:06:49.635479Z", "completed_at": "2025-02-23T10:06:49.636704Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.03604745864868164, "adapter_response": {}, "message": "Runtime Error in model costumer_elasticity (models/costumer_elasticity.py)\n  Materialization \"materialization_table_sqlite\" only supports languages ['sql']; got \"python\"", "failures": null, "unique_id": "model.elasticity_project.costumer_elasticity", "compiled": true, "compiled_code": "import pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\n\ndef model(dbt, session):\n    \"\"\"\n    Calcula a elasticidade por cliente, analisando:\n      - A soma das quantidades (de todos os produtos) que o cliente comprou na semana\n      - O pre\u00e7o m\u00e9dio (m\u00e9dio dos sale_prices) na semana\n    \"\"\"\n    orders_df = dbt.source(\"raw_data\", \"orders\").to_pandas()\n    orders_df['timestamp'] = pd.to_datetime(orders_df['timestamp'])\n    orders_df['week'] = orders_df['timestamp'].dt.to_period('W')\n\n    # Agrega por (customer_id, semana)\n    cust_agg = (\n        orders_df\n        .groupby(['customer_id', 'week'], as_index=False)\n        .agg({\n            'quantity': 'sum',\n            'sale_price': 'mean'\n        })\n    )\n\n    # Remover linhas com quantity=0 ou sale_price=0\n    cust_agg = cust_agg[\n        (cust_agg['quantity'] > 0) & (cust_agg['sale_price'] > 0)\n    ].copy()\n\n    cust_agg['ln_qty'] = np.log(cust_agg['quantity'])\n    cust_agg['ln_price'] = np.log(cust_agg['sale_price'])\n\n    results = []\n    for customer_id, group in cust_agg.groupby('customer_id'):\n        # \u00c9 necess\u00e1rio ao menos 2 pontos para estimar a regress\u00e3o\n        if len(group) < 2:\n            elasticity = None\n        else:\n            X = sm.add_constant(group['ln_price'])\n            y = group['ln_qty']\n            model_fit = sm.OLS(y, X).fit()\n            elasticity = model_fit.params['ln_price']\n\n        results.append({\n            'customer_id': customer_id,\n            'elasticity': elasticity\n        })\n\n    customer_elasticity_df = pd.DataFrame(results)\n    return customer_elasticity_df\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {\"raw_data.orders\": \"main.\\\"orders\\\"\"}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"/home/patrick/llm_pricing/example.db\"\n    schema = \"main\"\n    identifier = \"costumer_elasticity\"\n    \n    def __repr__(self):\n        return 'main.\"costumer_elasticity\"'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "main.\"costumer_elasticity\"", "batch_results": null}, {"status": "error", "timing": [{"name": "compile", "started_at": "2025-02-23T10:06:49.646017Z", "completed_at": "2025-02-23T10:06:49.649766Z"}, {"name": "execute", "started_at": "2025-02-23T10:06:49.650275Z", "completed_at": "2025-02-23T10:06:49.651447Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.008718252182006836, "adapter_response": {}, "message": "Runtime Error in model customer_product_elasticity (models/customer_product_elasticity.py)\n  Materialization \"materialization_table_sqlite\" only supports languages ['sql']; got \"python\"", "failures": null, "unique_id": "model.elasticity_project.customer_product_elasticity", "compiled": true, "compiled_code": "import pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\n\ndef model(dbt, session):\n    \"\"\"\n    Calcula a elasticidade para cada combina\u00e7\u00e3o (cliente, produto).\n    Ou seja, v\u00ea como varia\u00e7\u00f5es no pre\u00e7o do produto X para um cliente Y \n    afetam a quantidade comprada pelo mesmo cliente, ao longo do tempo.\n    \"\"\"\n    orders_df = dbt.source(\"raw_data\", \"orders\").to_pandas()\n    orders_df['timestamp'] = pd.to_datetime(orders_df['timestamp'])\n    orders_df['week'] = orders_df['timestamp'].dt.to_period('W')\n\n    # Agrega por (customer_id, product_id, week)\n    cp_agg = (\n        orders_df\n        .groupby(['customer_id', 'product_id', 'week'], as_index=False)\n        .agg({\n            'quantity': 'sum',\n            'sale_price': 'mean'\n        })\n    )\n\n    # Exclui linhas de quantity=0 ou sale_price=0 (evitar log(0))\n    cp_agg = cp_agg[\n        (cp_agg['quantity'] > 0) & (cp_agg['sale_price'] > 0)\n    ].copy()\n\n    cp_agg['ln_qty'] = np.log(cp_agg['quantity'])\n    cp_agg['ln_price'] = np.log(cp_agg['sale_price'])\n\n    results = []\n    for (cust_id, prod_id), group in cp_agg.groupby(['customer_id','product_id']):\n        if len(group) < 2:\n            elasticity = None\n        else:\n            X = sm.add_constant(group['ln_price'])\n            y = group['ln_qty']\n            model_fit = sm.OLS(y, X).fit()\n            elasticity = model_fit.params['ln_price']\n\n        results.append({\n            'customer_id': cust_id,\n            'product_id': prod_id,\n            'elasticity': elasticity\n        })\n\n    cp_elasticity_df = pd.DataFrame(results)\n    return cp_elasticity_df\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {\"raw_data.orders\": \"main.\\\"orders\\\"\"}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"/home/patrick/llm_pricing/example.db\"\n    schema = \"main\"\n    identifier = \"customer_product_elasticity\"\n    \n    def __repr__(self):\n        return 'main.\"customer_product_elasticity\"'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "main.\"customer_product_elasticity\"", "batch_results": null}, {"status": "error", "timing": [{"name": "compile", "started_at": "2025-02-23T10:06:49.658171Z", "completed_at": "2025-02-23T10:06:49.661741Z"}, {"name": "execute", "started_at": "2025-02-23T10:06:49.662198Z", "completed_at": "2025-02-23T10:06:49.663330Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 0.007070779800415039, "adapter_response": {}, "message": "Runtime Error in model product_elasticity (models/product_elasticity.py)\n  Materialization \"materialization_table_sqlite\" only supports languages ['sql']; got \"python\"", "failures": null, "unique_id": "model.elasticity_project.product_elasticity", "compiled": true, "compiled_code": "import pandas as pd\nimport numpy as np\nimport statsmodels.api as sm\n\ndef model(dbt, session):\n    \"\"\"\n    Calcula a elasticidade de pre\u00e7o por produto (agrupando em per\u00edodos semanais)\n    e retorna um dataframe com colunas: product_id, elasticity.\n    \"\"\"\n    # 1. Ler dados da tabela \"orders\" referenciada no projeto dbt\n    orders_df = dbt.source(\"raw_data\", \"orders\").to_pandas()\n\n    # 2. Converter timestamp para datetime (se j\u00e1 n\u00e3o estiver)\n    orders_df['timestamp'] = pd.to_datetime(orders_df['timestamp'])\n\n    # 3. Agregar vendas por produto e por per\u00edodo (exemplo: semanal)\n    orders_df['week'] = orders_df['timestamp'].dt.to_period('W')\n\n    #    - quantidade total vendida (sum)\n    #    - pre\u00e7o m\u00e9dio efetivamente pago (mean) -> \"sale_price\" \n    product_agg = (\n        orders_df\n        .groupby(['product_id', 'week'], as_index=False)\n        .agg({\n            'quantity': 'sum',\n            'sale_price': 'mean'\n        })\n    )\n\n    # 4. Log transform (cuidando para excluir casos de quantity=0 ou price=0)\n    product_agg = product_agg[\n        (product_agg['quantity'] > 0) & (product_agg['sale_price'] > 0)\n    ].copy()\n    product_agg['ln_qty'] = np.log(product_agg['quantity'])\n    product_agg['ln_price'] = np.log(product_agg['sale_price'])\n\n    # 5. Para cada produto, rodar regress\u00e3o ln(Q) = alpha + beta ln(P)\n    results = []\n    for product_id, group in product_agg.groupby('product_id'):\n        # Precisamos de pelo menos 2 pontos para estimar uma reta\n        if len(group) < 2:\n            elasticity = None\n        else:\n            X = sm.add_constant(group['ln_price'])\n            y = group['ln_qty']\n            model_fit = sm.OLS(y, X).fit()\n            # O coeficiente de ln_price \u00e9 a elasticidade\n            elasticity = model_fit.params['ln_price']\n\n        results.append({\n            'product_id': product_id,\n            'elasticity': elasticity\n        })\n\n    product_elasticity_df = pd.DataFrame(results)\n\n    # Retornar como resultado do modelo\n    return product_elasticity_df\n\n\n# This part is user provided model code\n# you will need to copy the next section to run the code\n# COMMAND ----------\n# this part is dbt logic for get ref work, do not modify\n\ndef ref(*args, **kwargs):\n    refs = {}\n    key = '.'.join(args)\n    version = kwargs.get(\"v\") or kwargs.get(\"version\")\n    if version:\n        key += f\".v{version}\"\n    dbt_load_df_function = kwargs.get(\"dbt_load_df_function\")\n    return dbt_load_df_function(refs[key])\n\n\ndef source(*args, dbt_load_df_function):\n    sources = {\"raw_data.orders\": \"main.\\\"orders\\\"\"}\n    key = '.'.join(args)\n    return dbt_load_df_function(sources[key])\n\n\nconfig_dict = {}\n\n\nclass config:\n    def __init__(self, *args, **kwargs):\n        pass\n\n    @staticmethod\n    def get(key, default=None):\n        return config_dict.get(key, default)\n\nclass this:\n    \"\"\"dbt.this() or dbt.this.identifier\"\"\"\n    database = \"/home/patrick/llm_pricing/example.db\"\n    schema = \"main\"\n    identifier = \"product_elasticity\"\n    \n    def __repr__(self):\n        return 'main.\"product_elasticity\"'\n\n\nclass dbtObj:\n    def __init__(self, load_df_function) -> None:\n        self.source = lambda *args: source(*args, dbt_load_df_function=load_df_function)\n        self.ref = lambda *args, **kwargs: ref(*args, **kwargs, dbt_load_df_function=load_df_function)\n        self.config = config\n        self.this = this()\n        self.is_incremental = False\n\n# COMMAND ----------\n\n\n", "relation_name": "main.\"product_elasticity\"", "batch_results": null}], "elapsed_time": 0.16312217712402344, "args": {"log_file_max_bytes": 10485760, "print": true, "empty": false, "require_batched_execution_for_custom_microbatch_strategy": false, "use_colors_file": true, "warn_error_options": {"include": [], "exclude": []}, "defer": false, "populate_cache": true, "macro_debugging": false, "state_modified_compare_more_unrendered_values": false, "project_dir": "/home/patrick/llm_pricing", "state_modified_compare_vars": false, "indirect_selection": "eager", "profiles_dir": "/home/patrick/llm_pricing", "log_format": "default", "write_json": true, "log_level_file": "debug", "invocation_command": "dbt run", "show_resource_report": false, "require_explicit_package_overrides_for_builtin_materializations": true, "strict_mode": false, "require_nested_cumulative_type_params": false, "require_yaml_configuration_for_mf_time_spines": false, "static_parser": true, "partial_parse_file_diff": true, "cache_selected_only": false, "quiet": false, "send_anonymous_usage_stats": true, "source_freshness_run_project_hooks": false, "favor_state": false, "introspect": true, "use_colors": true, "vars": {}, "partial_parse": true, "skip_nodes_if_on_run_start_fails": false, "log_format_file": "debug", "exclude": [], "version_check": true, "which": "run", "log_level": "info", "select": [], "log_path": "/home/patrick/llm_pricing/logs", "require_resource_names_without_spaces": false, "printer_width": 80}}